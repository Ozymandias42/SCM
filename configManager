#!/bin/bash

###LIBRARIES TO LOAD
source ../Functional-Bash/functional.sh
[ -e $HOME/.scm ] && source $HOME/.scm
#CONFIG FILE SHOULD LOOK STH LIKE THIS:
#MAINDIR="$HOME/user/.configStore"
#STORE="$MAINDIR/STORE"
#META="$MAINDIR/META"
#SECURE="$MAINDIR/SECURE"
#SMETA="$SECURE/META"

###START GLOBAL CONSTANTS

flags=(
#possible flags to supply to the scriipt
#format fullversion;s[hort]
       "--help;-h"
       "add;a"
       "justadd;ja"
       "link;l"
       "unlink;ul"
       "update;up"
       "modify;mod"
       "remove;rm"
       "initialise;init"
       "init-secure-store;inits"
       "report;rp"
       "--tag;-t"
       "--secure;-s"
       "--carefully")

descriptions=("$(basename $0) command --flag --tag tag1,tag2,tagN file\nPrints this help"
              "Adds file to the config-store and replaces original with symlink"
              "Adds file to the config-store without replacing the original"
              "Creates symlink to specified file[s in [-t]ag-group]"
              "Removes symlink for specified file[s in [-t]ag-group]"
              "Checks existing symlinks. Updates them if necessary"
              "Allows the user to modify a files's config"
              "Removes from storage"
              "Initialises config-storage with supplied git-repo"
              "Initialised secure config-storage and secure-config daemon"
              "Print report about configs in effect"
              "Lets the user specify one or more tags. [tag1,tag2,..,tagN]"
              "Lets the user specify the mode of operation. Secure or insecure"
              "Asks the user whenever an operation requires a decision")

help(){
#Creates --help output
    #Formatting of --help output
    buildHelp() { printf "%${3}s\t %s" "${1}" "$2" ; printf "\n" ; }
    
    ###reformats list of flags by substituting ';' with ', ' use with ((p)ref)map
    flag4help(){ echo "${1/;/', '}" ; }
    
    #howto call: returnlongest [0-9]+ ".*" ###returns length of longest string in list
    ###use with ((p)ref)foldr
    returnlongest(){ [[ ${1} -ge ${#2} ]] && echo ${1} || echo ${#2} ; }
    
    helpflags=()
    prefmap flag4help flags[@] helpflags
    leftpadding=0
    preffoldr returnlongest helpflags[@] leftpadding
    res=()
    prefzipWith buildHelp helpflags[@] descriptions[@] res leftpadding[@]
    forEach echo res[@] 
 }

parseArguments(){
    local -n lpar=$1

    case ${BASH_ARGV[-1]} in
        "help"|"-h"|"--help"      ) lpar["CMD"]=help ;;
        "add"|"a"        ) lpar["CMD"]="add"  ;;
        "justadd"|"ja"   ) lpar["CMD"]=justadd ;;
        "link"|"l"       ) lpar["CMD"]=link ;;
        "update"|"up"    ) lpar["CMD"]=update ;;
        "modify"|"mod"   ) lpar["CMD"]=modify ;;
        "init"           );;
        "inits"          );;
        "report"|"rp"    );;
                        *) echo "ERROR: First parameter has to be command. See --help"; exit ;;
    esac

    for (( i=$((${#BASH_ARGV[@]}-2)); i>=0; i-- )); do
        case ${BASH_ARGV[$i]} in
        "--tag"|"-t")
            lpar["TAGS"]="${lpar["TAGS"]} $(echo ${BASH_ARGV[$(($i-1))]}|sed 's/,/\ /g') "
            i=$(($i-1))
            ;;
        "-s"|"--secure") 
            lpar["SECURE"]=1
            ;;
        
        "--carefully") 
            lpar["CAREFUL"]=1
            ;;
        
        *)
           # [[ -e ${BASH_ARGV[$i]} ]] \
           #     && lpar["PATHS"]="${lpar["PATHS"]} ${BASH_ARGV[$i]}" \
           #     || { echo "ERROR: ${BASH_ARGV[$i]} is neither command nor flag or file." ;
           #          exit ; }
            lpar["PATHS"]="${lpar["PATHS"]} ${BASH_ARGV[$i]}"
            ;;
        esac
    done
}

#Signature $1=file 2=tags $3=secure $4=interactive
createMETA(){
    FILENAME=$(basename ${1})
    FILEPATH=$(dirname $(readlink -f ${1}))
    TAGS=(${2})
    SECURE=${3:-0} #Sets secure to 0 if not set.
    INTERACTIVE=${4:-0} #Sets interactive to 0 if not set

    #if $HOME in FILEPATH || substitutes /home/<user>/ with HOME in METAFILE
    if [[ $(grep $HOME <<< $FILEPATH) ]]; then 
        DIRNAME="HOME/"$(cut -d '/' -f4- <<< $FILEPATH)
    else
        DIRNAME=$FILEPATH
        #Checks if in non-user-owned dir. Sets secure.
        [ ! -O $DIRNAME ] && SECURE=1 || SECURE=0
    fi
         
    #Create __META-File
    METAFILE="__META-$(basename $1)"
    [[ $SECURE -eq 1 ]] && METAFILE="$SMETA/${METAFILE}" || METAFILE="$META/${METAFILE}"
    touch ${METAFILE}
    ##NOTE: while >> is standard output-redirection <<- is here-docs
    ##SEE: http://tldp.org/LDP/abs/html/here-docs.html
    [[ $SECURE -eq 1 ]] && CMD="sudo tee" || CMD="cat"
        
    eval $CMD >> ${METAFILE} <<- EOF
FILENAME=$FILENAME 
DIRNAME=$DIRNAME
TAGS=${TAGS[@]}
SECURE=$SECURE
EOF

echo $SECURE
}

isNotInStore(){
    [ -e "$MAINDIR/META/__META-$(basename ${1})" ] && echo 0 || echo 1
}

#Signature add FILE2ADD suppliedTags[@] $secure $carefully
add(){ 
    local -n lpar=$1

    lpar["PATHS"]=$(filter isNotInStore ${lpar["PATHS"]})
    #TODO: Implement refmap that takes additional arguments to supplied function
    [ ${#lpar["PATHS"]} -eq 0 ] && { echo "Nothing to add. Everything is already in store"; exit ; }
    lpar["SECURE"]=$(refmap createMETA lpar["PATHS"] ${lpar["TAGS"]})
    
    ##createMETA returns the new value of SECURE 
    ##since it sets that value depending on the files location
    

    #Importing File and creating symlink in place

    local -a SECURE=(${lpar["SECURE"]})
    local -a PATHS=(${lpar["PATHS"]})

    for (( i=0; i<=${#PATHS[@]}; i++ )); do
        case ${SECURE[$i]} in 
            1) sudo mv ${PATHS[$i]} $SSTORE/
               sudo ln -s $SSTORE/$(basename ${PATHS[$i]}) $(readlink -f ${PATHS[$i]})
               ;;
            0) mv ${PATHS[$i]} $STORE/
               ln -s $STORE/$(basename ${PATHS[$i]}) $(readlink -f ${PATHS[$i]})
               ;;
        esac
    done
    
}

#link(){ 
#    
#}

#
#update(){ 
#    SUPPOSED_PATH=$(
#}

modify(){ 
    [[ -e $MAINDIR/META/__META-$1 ]] \
    && $EDITOR $MAINDIR/META/__META-$1 \
    || echo "--META-$1 does not exist"
}
#
#remove(){ ; }
#
#init(){ ; }
#
#inits(){ ; }
#
#report(){ ; }


main(){ #Entrypoint to the script
declare -A parameters # -A SUPER IMPORTANT. WONT WORK OTHERWISE: -A == associative array
parseArguments parameters 
#echo "COMMAND: ${parameters["CMD"]}"
#echo "TAGS: ${parameters["TAGS"]}"
#echo "FILES: ${parameters["PATHS"]}"

${parameters["CMD"]} parameters
}
main
